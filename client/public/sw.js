// File: public/sw.js - ENHANCED SERVICE WORKER WITH WORKBOX
// This will be processed by Vite PWA plugin with Workbox

import { CacheableResponsePlugin } from 'workbox-cacheable-response'
import { ExpirationPlugin } from 'workbox-expiration'
import { cleanupOutdatedCaches, precacheAndRoute } from 'workbox-precaching'
import { NavigationRoute, registerRoute } from 'workbox-routing'
import {
  CacheFirst,
  NetworkFirst,
  StaleWhileRevalidate,
} from 'workbox-strategies'

// Precache all assets generated by the build process
precacheAndRoute(self.__WB_MANIFEST || [])

// Clean up old caches
cleanupOutdatedCaches()

// Skip waiting and claim clients
self.skipWaiting()
self.addEventListener('activate', (event) => {
  event.waitUntil(clients.claim())
})

// Cache strategies for different types of requests
// API calls - Network first, fallback to cache
registerRoute(
  ({ url }) => url.pathname.startsWith('/api/'),
  new NetworkFirst({
    cacheName: 'api-cache',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 60 * 60 * 24, // 24 hours
      }),
    ],
  })
)

// Images - Cache first
registerRoute(
  ({ request }) => request.destination === 'image',
  new CacheFirst({
    cacheName: 'images-cache',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 60 * 60 * 24 * 30, // 30 days
      }),
    ],
  })
)

// Static resources - Stale while revalidate
registerRoute(
  ({ request }) =>
    request.destination === 'style' ||
    request.destination === 'script' ||
    request.destination === 'font',
  new StaleWhileRevalidate({
    cacheName: 'static-resources',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
    ],
  })
)

// Navigation fallback for offline
const navigationHandler = new NetworkFirst({
  cacheName: 'navigations',
  plugins: [
    new CacheableResponsePlugin({
      statuses: [0, 200],
    }),
  ],
})

const navigationRoute = new NavigationRoute(navigationHandler, {
  // Optionally, provide a fallback if the network fails
  // This will use the offline page if available
})

registerRoute(navigationRoute)

// PUSH NOTIFICATION HANDLING - CRITICAL FOR BACKGROUND NOTIFICATIONS
self.addEventListener('push', (event) => {
  console.log('[Service Worker] Push notification received:', event)

  let notificationData = {
    title: 'ðŸ”” RadiantAI Notification',
    body: 'You have a new update!',
    icon: '/favicon_io/android-chrome-192x192.png',
    badge: '/favicon_io/android-chrome-192x192.png',
    tag: 'radiant-notification',
    requireInteraction: false,
    silent: false,
    data: {
      url: '/dashboard',
      timestamp: Date.now(),
    },
    vibrate: [200, 100, 200],
  }

  // Parse the push event data if available
  if (event.data) {
    try {
      const data = event.data.json()
      notificationData = {
        title: data.title || notificationData.title,
        body: data.body || data.message || notificationData.body,
        icon: data.icon || notificationData.icon,
        badge: data.badge || notificationData.badge,
        image: data.image,
        tag: data.tag || `notification-${Date.now()}`,
        requireInteraction: data.requireInteraction || false,
        silent: data.silent || false,
        vibrate: data.vibrate || [200, 100, 200],
        renotify: data.renotify || false,
        actions: data.actions || [],
        data: {
          ...notificationData.data,
          ...data.data,
          url: data.data?.url || data.url || '/dashboard',
          notificationId: data.data?.notificationId,
          category: data.data?.category,
        },
        timestamp: data.timestamp || Date.now(),
      }
    } catch (error) {
      console.error('[Service Worker] Error parsing push data:', error)
      // Try parsing as text
      try {
        notificationData.body = event.data.text()
      } catch (textError) {
        console.error(
          '[Service Worker] Error parsing push data as text:',
          textError
        )
      }
    }
  }

  // Show the notification
  event.waitUntil(
    self.registration.showNotification(notificationData.title, {
      body: notificationData.body,
      icon: notificationData.icon,
      badge: notificationData.badge,
      image: notificationData.image,
      tag: notificationData.tag,
      requireInteraction: notificationData.requireInteraction,
      silent: notificationData.silent,
      vibrate: notificationData.vibrate,
      renotify: notificationData.renotify,
      actions: notificationData.actions,
      data: notificationData.data,
      timestamp: notificationData.timestamp,
      dir: 'ltr',
      lang: 'en',
    })
  )
})

// Handle notification clicks
self.addEventListener('notificationclick', (event) => {
  console.log('[Service Worker] Notification clicked:', event)

  const notification = event.notification
  const action = event.action
  const data = notification.data || {}

  // Close the notification
  notification.close()

  if (action === 'dismiss') {
    // Just close the notification
    return
  }

  // Default action - open the app
  const urlToOpen = new URL(data.url || '/dashboard', self.location.origin).href

  event.waitUntil(
    clients
      .matchAll({
        type: 'window',
        includeUncontrolled: true,
      })
      .then((clientList) => {
        // Check if app is already open
        for (const client of clientList) {
          if (client.url === urlToOpen && 'focus' in client) {
            // Focus existing window
            client.focus()

            // Send message to the client about the notification
            client.postMessage({
              type: 'NOTIFICATION_CLICKED',
              notificationId: data.notificationId,
              category: data.category,
              action: action || 'open',
              url: data.url,
            })

            return
          }
        }

        // Check if any app window is open
        if (clientList.length > 0) {
          const client = clientList[0]
          // Navigate existing window to the notification URL
          return client.navigate(urlToOpen).then((windowClient) => {
            windowClient.focus()
            return windowClient
          })
        }

        // No app window is open, open a new one
        return clients.openWindow(urlToOpen)
      })
  )
})

// Handle notification close
self.addEventListener('notificationclose', (event) => {
  console.log('[Service Worker] Notification closed:', event)

  const data = event.notification.data || {}

  // Track notification dismissal if needed
  if (data.notificationId) {
    // Could send analytics event here
    console.log('[Service Worker] Notification dismissed:', data.notificationId)
  }
})

// Background sync for offline notifications
self.addEventListener('sync', (event) => {
  console.log('[Service Worker] Background sync:', event.tag)

  if (event.tag === 'sync-notifications') {
    event.waitUntil(
      // Sync notifications when back online
      syncNotifications()
    )
  }
})

// Helper function to sync notifications
async function syncNotifications() {
  try {
    console.log('[Service Worker] Syncing notifications...')

    // Get all clients
    const allClients = await clients.matchAll({
      includeUncontrolled: true,
    })

    // Notify all clients that sync occurred
    allClients.forEach((client) => {
      client.postMessage({
        type: 'SYNC_COMPLETE',
        timestamp: Date.now(),
      })
    })

    return true
  } catch (error) {
    console.error('[Service Worker] Sync failed:', error)
    return false
  }
}

// Periodic background sync (for compatible browsers)
self.addEventListener('periodicsync', (event) => {
  if (event.tag === 'check-notifications') {
    console.log('[Service Worker] Periodic sync: checking notifications')
    event.waitUntil(checkForNewNotifications())
  }
})

// Helper function for periodic checks
async function checkForNewNotifications() {
  try {
    console.log('[Service Worker] Checking for new notifications...')
    // Implementation would depend on your backend API
    return true
  } catch (error) {
    console.error('[Service Worker] Check failed:', error)
    return false
  }
}

// Listen for messages from the client
self.addEventListener('message', (event) => {
  console.log('[Service Worker] Message received:', event.data)

  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting()
  }

  if (event.data && event.data.type === 'TEST_NOTIFICATION') {
    // Handle test notification request
    self.registration.showNotification('ðŸŽ‰ Test Notification', {
      body: 'Push notifications are working perfectly!',
      icon: '/favicon_io/android-chrome-192x192.png',
      badge: '/favicon_io/android-chrome-192x192.png',
      tag: 'test-notification',
      requireInteraction: false,
      data: {
        url: '/dashboard',
        test: true,
      },
      vibrate: [200, 100, 200],
    })
  }
})

console.log('[Service Worker] Loaded and ready for push notifications!')
